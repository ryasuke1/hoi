### Лабораторная: микросервис генерации RSA-ключей и X509 по TCP (NIO)

- **Функционал**: сервер по TCP принимает имя (ASCII, null-terminated), возвращает существующую или генерирует новую пару: приватный ключ RSA-8192 и X509-сертификат (Subject = имя, Issuer фиксированный). Кэш по имени в памяти. Повторные запросы до завершения генерации получают тот же результат (через общий Future).
- **Производительность**: генерация в фиксированном пуле нитей; коммуникации через `Selector`, без одной нити на соединение. Поддерживает множество одновременных клиентов, включая медленных.
- **Клиент**: соединяется, отправляет имя, опционально ждет `--delay` секунд, либо завершает до чтения `--abort`. Сохраняет `.key` (PEM PKCS#8) и `.crt` (PEM X.509).

### Зависимости и версия Java
- Java 21 (Gradle toolchain настраивает автоматически)
- BouncyCastle: `bcprov-jdk18on`, `bcpkix-jdk18on`

### Подготовка ключа подписанта (Issuer Private Key)
Нужен приватный ключ Issuer в PKCS#8 PEM. Пример генерации с OpenSSL:

```bash
openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -out issuer.key
```

DN Issuer задается параметром `--issuer`, например: `"CN=Test CA"`.

### Сборка
```bash
./gradlew build
```

### Запуск сервера
```bash
./gradlew runServer --args "--host 0.0.0.0 --port 9000 --issuer 'CN=Test CA' --signing-key issuer.key --generator-threads 4"
```

Параметры:
- `--host` (по умолчанию `0.0.0.0`)
- `--port` (по умолчанию `9000`)
- `--issuer` (обязателен), пример: `CN=Test CA`
- `--signing-key` (обязателен), путь к приватному ключу Issuer (PEM PKCS#8)
- `--generator-threads` (по умолчанию = числу ядер)

### Запуск клиента
```bash
./gradlew runClient --args "--server 127.0.0.1 --port 9000 --name alice --delay 2"
```

Опции клиента:
- `--server` (адрес сервера)
- `--port` (порт)
- `--name` (имя, ASCII)
- `--delay` секунды задержки перед чтением ответа (имитация медленного клиента)
- `--abort` true/false — завершить после отправки запроса, не читая ответ

Результаты сохраняются в файлы `<name>.key` и `<name>.crt` в PEM.

### Протокол обмена (простая бинарная схема)
- Клиент → Сервер: `ASCII(name)` + `0x00`
- Сервер → Клиент:
  - Успех: `[0x00][int32 lenPriv][DER PKCS#8][int32 lenCert][DER X.509]`
  - Ошибка: `[0x01][int32 lenMsg][UTF-8 message]`

### Важные детали реализации
- Сервер использует один `Selector` для приема/чтения/записи; генерация уходит в пул нитей.
- Кэш: `ConcurrentHashMap<String, CompletableFuture<...>>` для дедупликации одновременных запросов одного имени.
- Сертификат выпускается через BouncyCastle `X509v3CertificateBuilder`, `SHA256withRSA`.
- Клиент сохраняет ключ/сертификат в PEM через `JcaPEMWriter`.

### Предупреждение по безопасности
Не используйте подобную схему (раздача приватных ключей) в реальных системах.



